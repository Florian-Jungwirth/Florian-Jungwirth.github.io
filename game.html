<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Space</title>
    <link rel="preconnect" href="https://fonts.gstatic.com">
    <link href="https://fonts.googleapis.com/css2?family=Bungee+Shade&display=swap" rel="stylesheet">

    <link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
    <style>
        body {
            margin: 0;
        }

        canvas {
            display: block;
        }

        #counter {
            position: absolute;
            left: 0.75em;
            margin: 0;
            color: white;
            font-size: 2.5em;
            font-family: 'Bungee Shade', cursive;
            padding: 0;
        }

        #gameOver,
        #pauseWindow,
        #countdown {
            height: 100%;
            width: 0;
            position: fixed;
            z-index: 10;
            top: 0;
            overflow-x: hidden;
            transition: 0.5s;
            background-color: rgba(0, 0, 0, 0.9);
            display: flex;
            justify-content: center;
            align-items: center;
            flex-direction: column;
            color: white;
            font-size: 150%;
        }

        #countdown {
            width: 100vw;
            background: white;
            color: black;
            font-size: 500%;
            font-family: 'Bungee Shade', cursive;
        }

        .btn {
            border: none;
            background-color: teal;
            padding: 0.5em;
            margin-top: 1em;
            font-size: 70%;
            border-radius: 5px;
            color: white;
            cursor: pointer;
        }

        #speaker {
            right: 1em;
            bottom: 1em;
            position: absolute;
            font-size: 150%;
            z-index: 0;
        }

        .btn:hover {
            box-shadow: inset 0 0 5px 5px rgba(255, 255, 255, 0.5);
        }

        #pause {
            position: absolute;
            right: 0.75em;
            margin: 0;
            font-size: 2em;
            padding: 0 0.4em;
            font-family: 'Bungee Shade', cursive;
            color: white;
            cursor: pointer;
            transition: all 0.3s;
        }

        #pause:hover {
            transform: rotateX(360deg);
            color: deepskyblue;
        }

        #speakerSlider,
        #label {
            position: absolute;
            font-size: 110%;
            bottom: 8em;
            right: 0em;
            z-index: 0;
        }

        #label {
            bottom: 13em;
            right: 2.8em;
            color: white;
        }

        #speakerSlider {
            transform: rotate(270deg);
            fill: teal;
        }

        .speaerSliderNotDropped {
            width: 0;
            height: 0;
            overflow: hidden;
            transform: rotate(270deg);
        }
    </style>
</head>

<body>
    <p id="counter">0</p>
    <p id="pause">Press Space to ||</p>
    <div id="gameOver">
        <h1>Game Over!</h1>
        <p id="lastScore"></p>
        <button class="btn" onclick="window.location.replace('game.html')">&#8634; Play again</button>
        <button class="btn" onclick="window.location.replace('settings.html')">&#x2302; Menu</button>
    </div>

    <div id="pauseWindow">
        <h1>| |</h1>
        <button class="btn" id="pauseMenu">Menu</button>
    </div>

    <button class="btn" id="speaker">&#128362; (M)</button>
    <input type="range" id="speakerSlider" name="speaker" min="0" max="1" step="0.01" class="speakerSliderNotDropped"
        value="1">
    <label id="label" for="speaker">100%</label>

    <div id="countdown">

    </div>

    <script src="/three.js"></script>
    <script type="module" src="/GLTFLoader.js"></script>
    <script type="module">
        /**
         * Daten werden aus sessionstorage geladen und fÃ¼r spÃ¤tere Verwendung gespeichert
        */
        let players = JSON.parse(localStorage.players);
        let currentUser = JSON.parse(localStorage.currentUser);
        let playerInArray;
        let playerInArrayNumber;
        let gameOverField = document.querySelector('#gameOver');
        let lastScore = document.querySelector('#lastScore');
        let counter = 0;
        let isPaused = false;
        let isGameOver = false;
        let gameStarted = false;

        let mute;
        try {
            mute = JSON.parse(sessionStorage.mute);
        } catch {
            mute = false;
        }


        let audio = {
            background: new Audio('/sounds/background.mp3'),
            point: new Audio('/sounds/point.wav'),
            gameOverSound: new Audio('/sounds/gameOver.wav'),
            countdownSound: [new Audio('/sounds/countdown/1.mp3'), new Audio('/sounds/countdown/2.mp3'), new Audio('/sounds/countdown/3.mp3')]
        };

        let speaker = document.querySelector('#speaker');

        let label = document.querySelector('#label');
        let slider = document.querySelector('#speakerSlider');

        if (sessionStorage.volume != undefined) {
            slider.value = JSON.parse(sessionStorage.volume);
            label.innerHTML =  Math.round(slider.value * 100) + '%';

            setVolume(slider.value);
        } else {
            speaker.innerHTML = '&#128362; (M)';
            mute = false;
        }

        if (slider.value == 1) {
            speaker.innerHTML = '&#128362; (M)';
            mute = false;
        } else if (slider.value == 0) {
            speaker.innerHTML = '&#128360; (M)';
            mute = true;
        } else {
            speaker.innerHTML = '&#128361; (M)';
            mute = false;
        }

        slider.addEventListener('input', () => {
            label.innerHTML = Math.round(slider.value * 100) + '%';
            sessionStorage.volume = JSON.stringify(slider.value);

            setVolume(slider.value);

            if (slider.value == 1) {
                speaker.innerHTML = '&#128362; (M)';
                mute = false;
                if (!isPaused && !isGameOver) {
                    audio.background.play();
                }
            } else if (slider.value == 0) {
                speaker.innerHTML = '&#128360; (M)';
                mute = true;
                if (!isPaused && !isGameOver) {
                    audio.background.pause();
                }
            } else {
                speaker.innerHTML = '&#128361; (M)';
                if (!isPaused && !isGameOver) {
                    audio.background.play();
                }
                mute = false;
            }
        });

        speaker.addEventListener('click', () => { toggleSound() });

        setVolume(JSON.parse(sessionStorage.volume));

        function setVolume(volume) {
            audio.background.volume = volume;
            audio.point.volume = volume;
            audio.gameOverSound.volume = volume;
            for (const element of audio.countdownSound) {
                element.volume = volume;
            }
        }

        function toggleSound() {
            if (speaker.innerHTML == 'ðŸ•ª (M)') {
                speaker.innerHTML = 'ðŸ•¨ (M)';
                mute = true;
                setVolume(0);
                slider.value = 0;
                label.innerHTML = '0%';
                if (!isPaused && !isGameOver) {
                    audio.background.pause();
                }
            } else if (speaker.innerHTML == 'ðŸ•¨ (M)') {
                speaker.innerHTML = 'ðŸ•© (M)';
                mute = false;
                setVolume(0.5);
                slider.value = 0.5;
                label.innerHTML = '50%';
                if (!isPaused && !isGameOver) {
                    audio.background.play();
                }
            } else {
                speaker.innerHTML = 'ðŸ•ª (M)';
                mute = false;
                setVolume(1);
                slider.value = 1;
                label.innerHTML = '100%';
                if (!isPaused && !isGameOver) {
                    audio.background.play();
                }
            }

            sessionStorage.volume = JSON.stringify(slider.value);
            sessionStorage.mute = JSON.stringify(mute)
        }

        audio.background.loop = true;

        for (let i = players.length - 1; i >= 0; i--) {
            if (players[i].name == currentUser) {
                playerInArray = players[i];
                playerInArrayNumber = i;
            }
        }



        /**
         * Bei Aufruf wird das gameOver Fenster angezeigt und der Counter (Score) als Highscore gespeichert, falls er grÃ¶ÃŸer als der bereits gespeicherte
         * Score ist
        */
        function gameOver() {
            isGameOver = true;
            if (!mute) {
                audio.gameOverSound.play();
                audio.background.pause();
            }
            gameOverField.style.width = '100vw';
            lastScore.innerHTML = 'Your score was: ' + counter;
            if (counter > playerInArray.counter) {
                players[playerInArrayNumber].counter = counter;
                localStorage.players = JSON.stringify(players);
            }
        }

        import { GLTFLoader } from "./GLTFLoader.js";


        /**
         * Hier wird die Game Function aufgerufen und zwar mit dem Model und Hintergrundpfad als Parameter
        */
        game(playerInArray.spaceshipDesign, playerInArray.backgroundDesign);


        function game(model, background) {
            let check = false;
            let rightArrow = false;
            let leftArrow = false;
            let upArrow = false;
            let downArrow = false;
            let innerHeightHalf = window.innerHeight / 2;
            let innerWidthHalf = window.innerWidth / 2;
            let counterHTML = document.querySelector('#counter');
            let pause = document.querySelector('#pause');
            let xGenerell = window.innerWidth / 1920;
            let speed = 13;
            let pauseWindow = document.querySelector('#pauseWindow');
            let currentObjectIsMeteorit = false;
            let isNotThrough = true;
            let pauseMenu = document.querySelector('#pauseMenu');
            let countdown = document.querySelector('#countdown');

            //Eventlistener fÃ¼r Button im Pausefenster
            pauseMenu.addEventListener('click', () => { gameOver(); window.location.replace('settings.html'); });

            //Eventlistener fÃ¼r die Schrift rechts oben
            pause.addEventListener('click', () => { pauseFunction() });

            //Bei Aufruf wird die animate() function gestoppt und das Pausefenster geÃ¶ffnet beziehungsweise wenn das Spiel bereits pausiert ist genau umgekehrt
            function pauseFunction() {
                audio.background.pause();
                if (!isGameOver) {
                    if (isPaused) {
                        requestAnimationFrame(animate);
                        isPaused = false;
                        pauseWindow.style.width = '0vw';
                        pause.innerHTML = 'Press Space to ||';
                        counterHTML.style.zIndex = 0;
                        pause.style.zIndex = 0;
                        if (!mute) {
                            audio.background.play();
                        }
                    } else {
                        cancelAnimationFrame(id);
                        isPaused = true;
                        pauseWindow.style.width = '100vw';
                        pause.innerHTML = 'Press Space to &#9655;';
                        counterHTML.style.zIndex = 23455;
                        pause.style.zIndex = 23455;
                        if (!mute) {
                            audio.background.pause();
                        }
                    }
                }
            }


            countdownFunction();
            /**
             * Diese Funtkion ist ein Timer, der immer beim neuladen des Spiels erscheint und wenn er aus ist wird die
             * animate() function aufgerufen und das Spiel gestertet
            */
            function countdownFunction() {
                let currentColor;
                if (sessionStorage.color !== undefined) {
                    currentColor = JSON.parse(sessionStorage.color);
                } else {
                    currentColor = 'white';
                }

                if (currentColor == 'black') {
                    countdown.style.backgroundColor = 'rgb(16,16,16)';
                    countdown.style.color = 'white';
                }

                let timeleft = 3;
                let timer = setInterval(function () {
                    if (timeleft == 0) {
                        clearInterval(timer);
                        animate();
                        if (!mute) {
                            audio.background.play();
                        }
                        countdown.style.width = 0;
                        document.onkeydown = keyDownListener;
                        label.style.zIndex = 23455;
                        slider.style.zIndex = 23455;
                        speaker.style.zIndex = 23455;

                    } else {
                        countdown.innerHTML = timeleft;
                        if (!mute) {
                            audio.countdownSound[timeleft - 1].play();
                        }
                    }
                    timeleft -= 1;
                }, 1000);
            }

            var scene = new THREE.Scene();
            var camera = new THREE.PerspectiveCamera(
                75,
                window.innerWidth / window.innerHeight,
                0.01,
                4000
            );
            var renderer = new THREE.WebGLRenderer();
            renderer.setSize(window.innerWidth, window.innerHeight);
            document.body.appendChild(renderer.domElement);

            var loader = new GLTFLoader();



            //Die nÃ¤chsten drei Zeilen sind wichtig, damit alle Objekte gleich skaliert sind
            var desiredScaleSpaceShip = window.innerHeight / 4;
            var scaleV3SpaceShip = new THREE.Vector3().setScalar(desiredScaleSpaceShip);
            let sizeSpaceship = new THREE.Vector3();

            var spaceship;
            //Hier wird das Raumschiff geladen und die GrÃ¶ÃŸe gespeichert
            loader.load(`${model}/scene.gltf`, function (gltf) {
                spaceship = gltf.scene;

                var box = new THREE.Box3();
                box.setFromObject(spaceship);

                var size = new THREE.Vector3();
                box.getSize(size);

                var center = new THREE.Vector3();
                box.getCenter(center);

                var scaleTemp = new THREE.Vector3().copy(scaleV3SpaceShip).divide(size);

                var scale = Math.min(scaleTemp.x, Math.min(scaleTemp.y, scaleTemp.z));
                spaceship.scale.setScalar(scale);

                spaceship.position.sub(center.multiplyScalar(scale));
                spaceship.position.z = -200;

                scene.add(spaceship);
                var box1 = new THREE.Box3();
                box1.setFromObject(spaceship);
                box1.getSize(sizeSpaceship);
            });



            //Die nÃ¤chsten drei Zeilen sind wichtig, damit alle Objekte gleich skaliert sind
            var desiredScaleRing = window.innerHeight / 3;
            var scaleV3Ring = new THREE.Vector3().setScalar(desiredScaleRing);
            var sizeRing = new THREE.Vector3();

            var ring;
            //Hier wird der Ring geladen und die GrÃ¶ÃŸe gespeichert
            loader.load("ring/scene.gltf", function (gltf) {
                ring = gltf.scene;

                var box = new THREE.Box3();
                box.setFromObject(ring);

                var size = new THREE.Vector3();
                box.getSize(size);

                var center = new THREE.Vector3();
                box.getCenter(center);

                var scaleTemp = new THREE.Vector3().copy(scaleV3Ring).divide(size);
                var scale = Math.min(scaleTemp.x, Math.min(scaleTemp.y, scaleTemp.z));
                ring.scale.setScalar(scale);

                ring.position.sub(center.multiplyScalar(scale));

                ring.position.z = -2500;
                ring.position.x = Math.floor(Math.random() * ((innerWidthHalf) - (-innerWidthHalf) + 1)) + (-innerWidthHalf);
                ring.position.y = Math.floor(Math.random() * ((innerHeightHalf) - (-innerHeightHalf) + 1)) + (-innerHeightHalf);

                scene.add(ring);
                var box1 = new THREE.Box3();
                box1.setFromObject(ring);
                box1.getSize(sizeRing);
            });



            //Die nÃ¤chsten drei Zeilen sind wichtig, damit alle Objekte gleich skaliert sind
            var desiredScaleMeteorite = window.innerHeight / 1.5;
            var scaleV3Meteorite = new THREE.Vector3().setScalar(desiredScaleMeteorite);
            var sizeMeteorite = new THREE.Vector3();

            var meteorite;
            //Hier wird der Meteorit geladen und die GrÃ¶ÃŸe gespeichert
            loader.load("meteorite/scene.gltf", function (gltf) {
                meteorite = gltf.scene;

                var box = new THREE.Box3();
                box.setFromObject(meteorite);

                var size = new THREE.Vector3();
                box.getSize(size);

                var center = new THREE.Vector3();
                box.getCenter(center);

                var scaleTemp = new THREE.Vector3().copy(scaleV3Meteorite).divide(size);
                var scale = Math.min(scaleTemp.x, Math.min(scaleTemp.y, scaleTemp.z));
                meteorite.scale.setScalar(scale);


                meteorite.position.sub(center.multiplyScalar(scale));
                meteorite.position.z = 2000;

                scene.add(meteorite);
                var box1 = new THREE.Box3();
                box1.setFromObject(meteorite);
                box1.getSize(sizeMeteorite);
                setTimeout(() => { scene.remove(meteorite), meteorite.position.z = -2000 }, 3000);
            });


            //In den folgenden Zeilen werden Hintergrund, Kameraposition, Lichter und Kontrast angepasst
            const textureLoader = new THREE.TextureLoader();
            const bgTexture = textureLoader.load(`${background}/background.jpg`);
            scene.background = bgTexture;
            var light = new THREE.HemisphereLight(0xffffff, 0x000000, 5);
            scene.add(light);
            renderer.toneMapping = THREE.ReinhardToneMapping;
            renderer.toneMappingExposure = 2;
            camera.position.y = 100;
            camera.position.z = 100;

            document.onkeydown = keyDownListenerSound;

            function keyDownListenerSound(e) {
                if (e.keyCode == 77) {
                    toggleSound();
                }
            }


            //In dieser Funktion wird eingelesen, welche Taste gedrÃ¼ckt wird
            function keyDownListener(e) {
                if (e.keyCode == 39 || e.keyCode == 68) {
                    rightArrow = true;
                }

                if (e.keyCode == 38 || e.keyCode == 87) {
                    downArrow = true;
                }

                if (e.keyCode == 37 || e.keyCode == 65) {
                    leftArrow = true;
                }
                if (e.keyCode == 40 || e.keyCode == 83) {
                    upArrow = true;
                }
                if (e.keyCode == 32) {
                    pauseFunction();
                }
                if (e.keyCode == 77) {
                    toggleSound();
                }
            }

            //In dieser Funktion wird eingelesen, ob eine zuvor gedrÃ¼ckte Taste nun nicht mehr gedrÃ¼ckt ist
            document.onkeyup = nokey;
            function nokey(e) {
                check = true;

                if (e.keyCode == 39 || e.keyCode == 68) {
                    rightArrow = false;
                }
                if (e.keyCode == 38 || e.keyCode == 87) {
                    downArrow = false;
                }
                if (e.keyCode == 37 || e.keyCode == 65) {
                    leftArrow = false;
                }
                if (e.keyCode == 40 || e.keyCode == 83) {
                    upArrow = false;
                }
            }



            let id;     //wird benÃ¶tigt um das Spiel zu stoppen

            function animate() {
                id = requestAnimationFrame(animate);

                if (currentObjectIsMeteorit) {
                    if (upArrow) {
                        check = false;
                        if (meteorite.position.y > -innerHeightHalf) {
                            meteorite.position.y -= xGenerell * 15;
                        }
                        if (spaceship.rotation.x < 0.5) {
                            spaceship.rotation.x += 0.05;
                        }
                    }

                    if (downArrow) {
                        check = false;
                        if (meteorite.position.y < innerHeightHalf) {
                            meteorite.position.y += xGenerell * 15;
                        }
                        if (spaceship.rotation.x > -0.5) {
                            spaceship.rotation.x -= 0.05;
                        }
                    }

                    if (leftArrow) {
                        check = false;
                        if (meteorite.position.x < innerWidthHalf) {
                            meteorite.position.x += xGenerell * 15;
                        }
                        if (spaceship.rotation.y < 0.5) {
                            spaceship.rotation.y += 0.05;
                        }
                    }

                    if (rightArrow) {
                        check = false;
                        if (meteorite.position.x > -innerWidthHalf) {
                            meteorite.position.x -= xGenerell * 15;
                        }
                        if (spaceship.rotation.y > -0.5) {
                            spaceship.rotation.y -= 0.05;
                        }
                    }


                    //In folgenden drei Zeilen wird der Meteorit gedreht und vorwÃ¤rtsbewegt
                    meteorite.position.z += speed + 15;
                    /*meteorite.rotation.z += 0.005;
                    meteorite.rotation.y += 0.00005;*/




                    //Im folgenden If-statement wird Ã¼berprÃ¼ft, ob der Spieler den Meteorit trifft, wenn nein, wird der counter erhÃ¶ht und ansonsten wird gameOver() aufgerufen


                    //console.log(meteorite.position.x - sizeMeteorite.x / 2);
                    //console.log((spaceship.position.x - sizeSpaceship.x/2));

                    if ((meteorite.position.z) > (spaceship.position.z)) {
                        if (isNotThrough) {
                            if (((meteorite.position.x + sizeMeteorite.x / 2) < (spaceship.position.x - sizeSpaceship.x / 2) || (meteorite.position.x - sizeMeteorite.x / 2) > (spaceship.position.x + sizeSpaceship.x / 2)) || ((meteorite.position.y + sizeMeteorite.y / 2) < (spaceship.position.y - sizeSpaceship.y / 2) || (meteorite.position.y - sizeMeteorite.y / 2) > (spaceship.position.y + sizeSpaceship.y / 2))) {
                                counter++;
                                counterHTML.innerHTML = counter;
                                if (!mute) {
                                    audio.point.play();
                                }
                                if (counter % 5 == 0) {
                                    speed += 1;
                                }


                            } else if ((meteorite.position.z > spaceship.position.z)) {
                                isGameOver = true;
                                cancelAnimationFrame(id);
                                gameOver();
                            }
                        }
                        isNotThrough = false;
                        if (meteorite.position.z > (spaceship.position.z / 2)) {
                            meteorite.position.z = -3000;
                            ring.position.z = -2000;
                            meteorite.position.x = Math.floor(Math.random() * ((innerWidthHalf) - (-innerWidthHalf) + 1)) + (-innerWidthHalf);
                            meteorite.position.y = Math.floor(Math.random() * ((innerHeightHalf) - (-innerHeightHalf) + 1)) + (-innerHeightHalf);
                            isNotThrough = true;
                            scene.remove(meteorite);
                            scene.add(ring);
                            currentObjectIsMeteorit = false;
                        }
                    }







                } else {

                    if (upArrow) {
                        check = false;
                        if (ring.position.y > -innerHeightHalf) {
                            ring.position.y -= xGenerell * 15;
                        }
                        if (spaceship.rotation.x < 0.5) {
                            spaceship.rotation.x += 0.05;
                        }
                    }

                    if (downArrow) {
                        check = false;
                        if (ring.position.y < innerHeightHalf) {
                            ring.position.y += xGenerell * 15;
                        }
                        if (spaceship.rotation.x > -0.5) {
                            spaceship.rotation.x -= 0.05;
                        }
                    }

                    if (leftArrow) {
                        check = false;
                        if (ring.position.x < innerWidthHalf) {
                            ring.position.x += xGenerell * 15;
                        }
                        if (spaceship.rotation.y < 0.5) {
                            spaceship.rotation.y += 0.05;
                        }
                    }

                    if (rightArrow) {
                        check = false;
                        if (ring.position.x > -innerWidthHalf) {
                            ring.position.x -= xGenerell * 15;
                        }
                        if (spaceship.rotation.y > -0.5) {
                            spaceship.rotation.y -= 0.05;
                        }
                    }




                    //In folgenden Zeilen wird der Ring fortbewegt und gedreht
                    ring.position.z += speed;
                    ring.rotation.z += 0.01;




                    //Im folgenden If-statement wird Ã¼berprÃ¼ft, ob der Spieler den Ring trifft, wenn ja, wird der counter erhÃ¶ht und ansonsten wird gameOver() aufgerufen
                    if (ring.position.z > (spaceship.position.z)) {
                        if (isNotThrough) {
                            if (((ring.position.x - (sizeRing.x / 2))/*+sizeRing.z*/ < -(sizeSpaceship.x / 2)) && ((ring.position.x + (sizeRing.x / 2))/*-sizeRing.z*/ > (sizeSpaceship.x / 2)) && ((ring.position.y - (sizeRing.y / 2))/*+sizeRing.z*/ < -(sizeSpaceship.y / 2)) && ((ring.position.y + (sizeRing.y / 2))/*-sizeRing.z*/ > (sizeSpaceship.y / 2)) && (ring.position.z > spaceship.position.z)) {
                                counter++;
                                if (!mute) {
                                    audio.point.play();
                                }
                                counterHTML.innerHTML = counter;
                                if (counter % 5 == 0) {
                                    speed += 1;
                                }
                            } else if ((ring.position.z > spaceship.position.z)) {
                                isGameOver = true;
                                cancelAnimationFrame(id);
                                gameOver();
                            }
                        }
                        isNotThrough = false;

                        if (ring.position.z > (spaceship.position.z / 2)) {
                            if (!isGameOver) {
                                if (Math.floor(Math.random() * 4 + 1) === 2) {
                                    scene.add(meteorite);
                                    scene.remove(ring);
                                    currentObjectIsMeteorit = true;
                                }

                                isNotThrough = true;
                                ring.position.z = -2000;
                                meteorite.position.z = -3000;
                                ring.position.x = Math.floor(Math.random() * ((innerWidthHalf) - (-innerWidthHalf) + 1)) + (-innerWidthHalf);
                                ring.position.y = Math.floor(Math.random() * ((innerHeightHalf) - (-innerHeightHalf) + 1)) + (-innerHeightHalf);
                            }
                        }
                    }

                }


                //In diesem If-Statement wird das Raumschiff mÃ¶glichst realistisch in die Richtung gedreht, in die man fliegt
                if (check) {
                    let check2 = false;
                    let check3 = false;

                    if (spaceship.rotation.y > 0.05 || spaceship.rotation.y < -0.05) {
                        if (spaceship.rotation.y > 0) {
                            spaceship.rotation.y -= 0.02;
                        } else {
                            spaceship.rotation.y += 0.02;
                        }
                    } else {
                        check2 = true;
                    }

                    if (spaceship.rotation.x > 0.05 || spaceship.rotation.x < -0.05) {
                        if (spaceship.rotation.x > 0) {
                            spaceship.rotation.x -= 0.02;
                        } else {
                            spaceship.rotation.x += 0.02;
                        }
                    } else {
                        check3 = true;
                    }

                    if (check2 && check3) {
                        check = false;
                    }
                }

                renderer.render(scene, camera);

            }
        }
    </script>
</body>

</html>